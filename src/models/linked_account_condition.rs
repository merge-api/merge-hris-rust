/*
 * Merge HRIS API
 *
 * The unified API for building rich integrations with multiple HR Information System platforms.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: hello@merge.dev
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct LinkedAccountCondition {
    /// The ID indicating which condition schema to use for a specific condition.
    #[serde(rename = "condition_schema_id")]
    pub condition_schema_id: String,
    /// The common model for a specific condition.
    #[serde(rename = "common_model", skip_serializing_if = "Option::is_none")]
    pub common_model: Option<String>,
    /// User-facing *native condition* name. e.g. \"Skip Manager\".
    #[serde(rename = "native_name")]
    pub native_name: Option<String>,
    /// The operator for a specific condition.
    #[serde(rename = "operator")]
    pub operator: String,
    /// The value for a condition.
    #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
    /// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. \"location_type\".
    #[serde(rename = "field_name")]
    pub field_name: Option<String>,
}

impl LinkedAccountCondition {
    pub fn new(condition_schema_id: String, native_name: Option<String>, operator: String, field_name: Option<String>) -> LinkedAccountCondition {
        LinkedAccountCondition {
            condition_schema_id,
            common_model: None,
            native_name,
            operator,
            value: None,
            field_name,
        }
    }
}


